---
# Copyright 2017 IBM Corp.
#
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

- name: lxc-create.yml
  hosts: localhost
  vars:
    networks_only: False
  handlers:
    - include: handlers/restart_networking.yml
  tasks:
    - name: "Print local project path"
      debug:
        msg: "Project name: {{ project_path_local }}"

    - name: "Print back-up config file path"
      debug:
        msg: "Config file backup: {{ config_local_backup }}"

    - name: "Back-up config file"
      copy:
        src: "{{ config_local }}"
        dest: "{{ config_local_backup }}"
        mode: 0444

    - name: "Register management network subnet"
      shell: "grep ipaddr-mgmt-network {{ config_local }} | grep -v '^ *#' | awk '{print $2}'"
      register: ipaddr_mgmt_network

    - name: "Register management client network subnet"
      shell: "grep ipaddr-mgmt-client-network {{ config_local }} | grep -v '^ *#' | awk '{print $2}'"
      register: ipaddr_mgmt_client_network

    - name: "Register management VLAN"
      shell: "grep vlan-mgmt-network {{ config_local }} | grep -v '^ *#' | awk '{print $2}'"
      register: vlan_mgmt_network

    - name: "Register management client VLAN"
      shell: "grep vlan-mgmt-client-network {{ config_local }} | grep -v '^ *#' | awk '{print $2}'"
      register: vlan_mgmt_client_network

    - name: "Update group_vars/all container_mgmt_subnet with no VLAN support"
      replace:
        dest: "{{ project_path_local }}/playbooks/group_vars/all"
        regexp: '^(container_mgmt_subnet:).*$'
        replace: '\1 {{ ipaddr_mgmt_network.stdout }}'
      when: ipaddr_mgmt_client_network.stdout == ""

    - name: "Update group_vars/all container_mgmt_subnet with VLAN support"
      replace:
        dest: "{{ project_path_local }}/playbooks/group_vars/all"
        regexp: '^(container_mgmt_subnet:).*$'
        replace: '\1 {{ ipaddr_mgmt_client_network.stdout }}'
      when: ipaddr_mgmt_client_network.stdout != ""

    - name: "Create lxc.conf"
      vars:
        ipaddr_mgmt_cidr: "{{ ipaddr_mgmt_network.stdout | ipaddr(container_mgmt_ipv4_offset) }}"
        ipaddr_mgmt_client_cidr: "{{ ipaddr_mgmt_client_network.stdout | ipaddr(container_mgmt_ipv4_offset) }}"
        bridge_mgmt: "br{{ vlan_mgmt_network.stdout }}"
        bridge_mgmt_client: "br{{ vlan_mgmt_client_network.stdout }}"
      template:
        src: "{{ playbook_dir }}/templates/localhost/lxc-conf.j2"
        dest: "{{ playbook_dir }}/lxc.conf"
        mode: "0644"
      when: not networks_only

    - name: "Ubuntu: Create bridge interfaces for VLAN Support"
      vars:
        primary_port: "{{ mgmt_network_interface }}"
        ipaddr_cidr: "{{ item.network | ipaddr(container_bridge_ipv4_offset) }}"
        vlan: "{{ item.vlan }}"
        bridge: "br{{ item.vlan }}"
      template:
        src: "{{ playbook_dir }}/templates/localhost/bridge-vlan-ubuntu.j2"
        dest: "/etc/network/interfaces.d/{{ bridge }}"
        owner: "root"
        group: "root"
        mode: "0644"
      with_items:
        - { network: "{{ ipaddr_mgmt_network.stdout }}",
            vlan: "{{ vlan_mgmt_network.stdout }}"}
        - { network: "{{ ipaddr_mgmt_client_network.stdout }}",
            vlan: "{{ vlan_mgmt_client_network.stdout }}"}
      notify: "restart networking"
      become: yes
      become_method: sudo
      when:
        - ipaddr_mgmt_client_network.stdout != ""
        - ansible_distribution == 'Ubuntu'

    - name: "RHEL/CentOS: Enable IP Forwarding"
      lineinfile:
        dest: /etc/sysctl.conf
        regexp: '^net.ipv4.ip_forward'
        line: 'net.ipv4.ip_forward = 1'
      become: yes
      become_method: sudo
      when: ansible_distribution in ['RedHat','CentOS']

    - name: "RHEL/CentOS: Create bridge interfaces for VLAN Support"
      vars:
        primary_port: "{{ mgmt_network_interface }}"
        ipaddr_cidr: "{{ item[0].network | ipaddr(container_bridge_ipv4_offset) }}"
        vlan: "{{ item[0].vlan }}"
        bridge: "br{{ item[0].vlan }}"
      template:
        src: "{{ item[1].temp }}"
        dest: "/etc/sysconfig/network-scripts/ifcfg-{{ item[1].name }}{{ item[0].vlan }}"
        owner: "root"
        group: "root"
        mode: "0644"
      with_nested:
        -   - { network: "{{ ipaddr_mgmt_network.stdout }}",
                vlan: "{{ vlan_mgmt_network.stdout }}"}
            - { network: "{{ ipaddr_mgmt_client_network.stdout }}",
                vlan: "{{ vlan_mgmt_client_network.stdout }}"}
        -   - { temp: "{{ playbook_dir }}/templates/localhost/vlan-rhel.j2",
                name: "{{ mgmt_network_interface }}."}
            - { temp: "{{ playbook_dir }}/templates/localhost/bridge-rhel.j2",
                name: "br"}
      notify: "restart networking"
      become: yes
      become_method: sudo
      when:
        - ipaddr_mgmt_client_network.stdout != ""
        - ansible_distribution in ['RedHat','CentOS']

    - name: "Flush handlers"
      meta: flush_handlers

    - name: "Create private/public ssh key pair"
      user:
        name: "{{ ansible_env.USER }}"
        generate_ssh_key: yes
        ssh_key_file: "{{ ssh_key_private }}"
      when: not networks_only

    - name: "Create LXC deployment container"
      lxc_container:
        name: "{{ container_name }}"
        template: ubuntu
        template_options:
          --user {{ user }}
          --auth-key {{ ssh_key_public }}
          --release trusty
          --packages python,aptitude
        config: "{{ project_path_local }}/playbooks/lxc.conf"
        container_command: |
          cp -p /etc/sudoers /etc/sudoers.orig
          echo -e "{{ user }}\tALL=NOPASSWD: ALL" >> /etc/sudoers
      when: not networks_only
      become: yes
      become_method: sudo

    - name: "Pause 5 seconds"
      pause:
        seconds: 5
      when: not networks_only

    - name: "Register container internal ip address"
      command: lxc-info -n {{ container_name }}
      register: container_info
      when: not networks_only
      become: yes
      become_method: sudo

    - name: "Print container information"
      debug:
        msg: "{{ container_info.stdout.split('\n') }}"
      when: not networks_only

    - name: "Create Ansible host for \"deployer\""
      lineinfile:
        dest: "{{ project_path_local }}/playbooks/hosts"
        insertafter: '^\[deployers\]'
        regexp: '^deployer'
        line: >
          deployer ansible_user={{ user }}
          ansible_ssh_private_key_file={{ ssh_key_private }}
          ansible_host={{ ipaddr_mgmt_network.stdout |
          ipaddr(container_mgmt_ipv4_offset) | ipaddr("address") }}

    - name: Remove any existing known_hosts file
      file:
        path: "{{ known_hosts }}"
        state: absent
      when: not networks_only

    - name: Create known_hosts file
      file:
        path: "{{ known_hosts }}"
        state: touch
        mode: 0600
      when: not networks_only

    - name: |
        Use ssh-keyscan to collect container host keys (retry until ssh is up)
      command: |
        /usr/bin/ssh-keyscan -H {{ ipaddr_mgmt_network.stdout |
        ipaddr(container_mgmt_ipv4_offset) | ipaddr("address") }}
      register: ssh_keyscan_output
      until: ssh_keyscan_output.stdout != ''
      retries: 6
      delay: 10
      when: not networks_only

    - name: Append keys to playbooks/known_hosts and ~/.ssh/known_hosts
      lineinfile:
        line: "{{ item[0] }}"
        dest: "{{ item[1] }}"
        state: present
        create: "yes"
        mode: 0600
      with_nested:
        - "{{ ssh_keyscan_output.stdout_lines }}"
        -   - "{{ known_hosts }}"
            - "~/.ssh/known_hosts"
      when: not networks_only
